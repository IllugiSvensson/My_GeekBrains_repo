//Смирнов Александр
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define max(a,b) ((a > b) ? a : b)
#define N 4
#define M 5

int var[8][2]= { {2, 1}, {2, -1}, {1, 2}, {1, -2},
				 {-1, 2}, {-1, -2}, {-2, 1}, {-2, -1} };

int lcs_length_array(char *A, char *B) {

	int i, j, n, m, c;
    int array[strlen(A)][strlen(B)];

        n = strlen(A);
        m = strlen(B);
        
    	for(j = 0; j < m; j++) {
    	
    		if(B[j]	==	A[0])
				
				c = 1;
    			
			array[0][j] = c;
    	
		}
	
		c = 0;
	
		for(i = 0; i < n; i++) {
		
	    	if(B[0]	==	A[i]) 
				
				c = 1;
    	
			array[i][0] = c;	
		
		}
	
   		for(i = 1; i < n; i++) {
       
	   		for(j = 1; j < m ; j++) {
       	
       			if(A[i] == B[j]) 
				          			
				   	array[i][j] = 1 + array[i -1][j - 1];
       			
				else 
       		
					array[i][j] = max(array[i - 1][j], array[i][j - 1]);
	
			}
		}
	
	
	    for(i = 0; i < n; i++) {

                puts(" ");

        for(j = 0; j < m; j++)

                printf("%d ", array[i][j]);

    	}
    
    puts(" ");

return array[n - 1][m - 1];
}

int cntsteps(int x, int y, int A[M][M]) {

	int k, xn, yn;
    int count=0;
	    
		if((x < 0 || x >= M || y < 0 || y >= M || A[x][y] != 0)) {
			
        return -1;
        
    	}

    	for(k = 0; k < 8; k++) {
    		
       	 	xn = x + var[k][0];
        	yn = y + var[k][1];
        	
        		if(xn >= 0 && xn < M && yn >= 0 && yn < M && A[xn][yn] == 0) {
        			
            		count++;
            
        		}
   	 	}
   	 	
return count;
}

int main(int argc, char *argv[]) {

//1. Реализовать чтение массива с препятствием и нахождение количества маршрутов.

    int map[N][M] = { {1, 1, 0, 0, 1},
                      {1, 1, 1, 0, 1},
                      {0, 1, 1, 1, 1},
                      {0, 0, 1, 1, 1} };
    int i, j;

        for(i = 0; i < N - 1; i++) {

            if(map[i][0] == 0)

                map[i + 1][0] = 0;

        }

        for(j = 0; j < M - 1; j++) {

            if(map[0][j] == 0)

                map[0][j + 1] = 0;

        }

        for(i = 1; i < N; i++) {

            for(j = 1; j < M; j++) {

                if(map[i][j] == 0) continue;
                map[i][j] = map[i - 1][j] + map[i][j - 1];

            }

        }

        for (i = 0; i < N; i++) {

            for (j = 0; j < M; j++) {

                printf("%3d", map[i][j]);

            }

            puts(" ");

        }

    puts(" ");

//2. Решить задачу о нахождении длины максимальной последовательности
//с помощью матрицы.

        printf("Максимальная длина последовательности: %d\n", lcs_length_array("124421253", "151123"));

//3. Требуется обойти конем доску размером NxM пройдя по каждой клетке не более одного раза.

	int Arr[5][5] = {0};
	int steps[8];
	int x, y ,n, m;
	int sx = 0;
	int cnt = 1;
	 
	
		printf("Введите координату x стартовой позиции: ");
		scanf("%d", &x);
		printf("Введите координату y стартовой позиции: ");
		scanf("%d", &y);
	
	Arr[x][y] = 1;

		do {
			
			for(n = 0; n < 8; n++) {
				
				steps[n] = cntsteps(x + var[n][0], y + var[n][1], Arr);
				 
			}
			
			for(n = 0; n < 8; n++) {
				
				if(steps[n] > 0) {
					
					sx = n;
					break;
					
				}
				
				if(n == 7) {
					
					for(m = 0; m < 8; m++) {
						
						if(steps[m] == 0) {
							
							Arr[x + var[m][0]][y + var[m][1]] = ++cnt;
						}
						
					}
					
					for(i = 0; i < M; i++) {
						
						puts(" ");
						for(j = 0; j < M; j++) {
							
           			 		printf("%4d",Arr[i][j]);
           			 		
       				 	}
        			
    				}    
    				
					return 0;
						
				}
				
			}
			
			for(n = 0; n < 8; n++) {
				
				if(steps[n] < steps[sx] && steps[n] > 0) {
					
					sx = n;
					
				}
				
			}
			
				x += var[sx][0];
				y += var[sx][1];
				Arr[x][y] = ++cnt;
			
		} while (1);
	
return 0;
}
