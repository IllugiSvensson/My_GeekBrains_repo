1 2 3 4 5 6 7 8 9

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

typedef int T;
FILE *file;

typedef struct Node {   //Узел

    T data;             //Данные в корне
    struct Node *left;  //указатель на левое и правое поддерево
    struct Node *right;

} Node;

//Построение идеально сбалансированного дерева с n узлами
Node* Tree(int n) {

    Node* newNode;
    int x, nl, nr;

        if (n == 0)     //Если элементов нет, то строим пустое дерево

            newNode = NULL;

        else {          //Если элементы есть, считываем элемент

            fscanf(file, "%d", &x);
            nl = n / 2;
            nr = n - nl - 1;
            newNode = (Node*)malloc(sizeof(Node));  //Выделяем память под новый узел
            newNode->data = x;                      //Распределяем элементы в левое и правое
            newNode->left = Tree(nl);               //поддерево равномерно
            newNode->right = Tree(nr);

        }

return newNode;
}

//Распечатка двоичного дерева в виде скобочной записи
void printTree(Node *root) {

    if (root) {                                 //Если есть корень

        printf("%d", root->data);

            if (root->left || root->right) {    //Проверяем, есть ли ссылки на поддерева

                printf("(");                    //Если ссылка есть, рекурсивно обходим дерево

                    if (root->left)

                        printTree(root->left);

                    else

                        printf("NULL");

                printf(",");

                    if (root->right)

                        printTree(root->right);

                    else

                        printf("NULL");

                printf(")");

            }

    }

}

int main() {

    Node* tree = NULL;
    file = fopen("/home/woljin1/Projects/file","rt");

        if (file == NULL) {

            puts("Can't open file!");
            return 1;
        }

    int count = 0;
    fscanf(file, "%d", &count); //Считываем количество записей
    printf("%d", count);
    //tree = Tree(count);         //Строим дерево
    fclose(file);
    //printTree(tree);            //Печатаем скобочную запись
    //puts(" ");

return 0;
}


